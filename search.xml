<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring IOC和AOP</title>
      <link href="/2020/07/07/spring-ioc-he-aop/"/>
      <url>/2020/07/07/spring-ioc-he-aop/</url>
      
        <content type="html"><![CDATA[<h3 id="Spring-IOC和AOP的原理及相关面试题"><a href="#Spring-IOC和AOP的原理及相关面试题" class="headerlink" title="Spring IOC和AOP的原理及相关面试题"></a>Spring IOC和AOP的原理及相关面试题</h3><p>1.什么是IOC和DI?有什么区别？<br>控制反转(Ioc)：它不是技术，而是一种思想，将创建对象的控制权力交给spring框架。由Spring来负责控制对象的生命周期和对象间的关系，其核心是通过反射调用set方法来进行数据的注入。<br>依赖注入(DI)：指Spring创建对象的过程中，将对象依赖的属性（简单值，集合，对象）通过配置的方式进行设值。<br>IoC和DI其实是同一个概念的不同角度描述，DI相对IoC而言，明确描述了被管理的对象中，依赖的属性也应该由Spring容器自动注入<br>2.IOC容器的初始化过程?<br>(1).BeanDefinition的Resource定位<br>(2).BeanDefinition的载入<br>(3).向IoC容器注册BeanDefinition<br>IOC容器的初始化过程，一般不包含bean的依赖注入的实现，在spring IOC设计中，bean的注册和依赖注入是两个过程，，依赖注入一般发生在应用第一次索取bean的时候，但是也可以在xm中配置，在容器初始化的时候，这个bean就完成了初始化。<br>3.bean如何定义？<br>(1)xml文件<br>(2)Spring4.x的javaConfig方式<br>// 创建一个类，命名为SpringConfiguration<br>@Configuration<br>public class SpringConfiguration {<br>    @Bean<br>    @Scope(value = “singleton”)<br>    public Student student(){<br>        return new Student(11,”jack”,22);<br>    }<br>}<br>3.注入方式有哪几种？<br>构造方法注入<br>setter注入<br>基于注解注入（常用）<br>4.bean是如何创建的？<br>5.springIOC bean的生命周期？<br>1.实例化 Instantiation InstantiationAwareBeanPostProcessor<br>2.属性赋值 Populate<br>3.初始化 Initialization(可扩展) BeanPostProcessor<br>4.销毁 Destruction(可扩展)<br>在配置bean时，通过init-method和destroy-method 属性为bean指定初始化和销毁方法<br>6.bean的后置处理器<br>① bean后置处理器允许在调用初始化方法前后对bean进行额外的处理<br>② bean后置处理器对IOC容器里的所有bean实例逐一处理，而非单一实例。其典型应用是：检查bean属性的正确性或根据特定的标准更改bean的属性。<br>③ bean后置处理器时需要实现接口：<br>org.springframework.beans.factory.config.BeanPostProcessor。在初始化方法被调用前后，Spring将把每个bean实例分别传递给上述接口的以下两个方法：<br>*postProcessBeforeInitialization(Object, String)<br>*postProcessAfterInitialization(Object, String)<br>5.数据是如何注入的？<br>6.BeanFactory和FactoryBean的区别？<br>(1)都是接口<br>(2)BeanFactory是一个工厂类，用于管理Bean的一个工厂，在Spring中所有的Bean都是由BeanFactory（就是IOC容器）管理。<br>FactoryBean<br>这个Bean不是简单的Bean，而是一个能生产或者修饰对象生成的工厂Bean,它的实现与设计模式中的工厂模式和修饰器模式类似。<br>一般情况下，Spring通过反射机制利用<bean>的class属性指定实现类实例化Bean，在某些情况下，实例化Bean过程比较复杂，</bean></p><p>如果按照传统的方式，则需要在<bean>中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。</bean></p><p>Spring为此提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。<br>FactoryBean接口对于Spring框架来说占用重要的地位，Spring自身就提供了70多个FactoryBean的实现。</p><p>它们隐藏了实例化一些复杂Bean的细节，给上层应用带来了便利。从Spring3.0开始，FactoryBean开始支持泛型，即接口声明改为FactoryBean<t>的形式<br>利用反射<br>3.什么是AOP?<br>4.AOP的实现原理?<br>5.AOP应用场景?</t></p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组和链表对于内存以及CPU的访问缓存机制</title>
      <link href="/2020/06/04/arr-cpu/"/>
      <url>/2020/06/04/arr-cpu/</url>
      
        <content type="html"><![CDATA[<h3 id="CPU缓存对数组友好而对链表不友好"><a href="#CPU缓存对数组友好而对链表不友好" class="headerlink" title="CPU缓存对数组友好而对链表不友好"></a>CPU缓存对数组友好而对链表不友好</h3><p>数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，每一次CPU在读取内存中的数组时不是单纯的只读取某个特定的访问地址，而是读取一个<font color="red">数据块</font>（视情况而定的一段连续的内存地址），并保存到CPU的缓存中，下次访问时就会先从CPU缓存中查找，为的就是弥补CPU速度过快而内存过慢导致的速度差异。</p><p>对于数组和链表两种数据结构，由于数组是一块连续的内存空间，<font color="red">在读取某个下标的数据时CPU就会缓存连续的几个元素加载到缓存中，</font>而链表不是连续的，链表的节点是分散在堆空间（内存）里面,CPU缓存帮不上忙，这样数组执行速度会快于存储空间不连续的链表存储，理论上CPU访问数组比链表快了大约33倍</p><p>因此，程序中尽量使用连续的数据结构，这样可以充分发挥CPU缓存的威力。 这种对缓存友好的算法称为 <font color="red">Cache-oblivious algorithm</font></p>]]></content>
      
      
      <categories>
          
          <category> 缓存机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 链表 </tag>
            
            <tag> CPU缓存 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
