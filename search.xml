<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数组和链表对于内存以及CPU的访问缓存机制</title>
      <link href="/2020/06/04/arr-cpu/"/>
      <url>/2020/06/04/arr-cpu/</url>
      
        <content type="html"><![CDATA[<h3 id="CPU缓存对数组友好而对链表不友好"><a href="#CPU缓存对数组友好而对链表不友好" class="headerlink" title="CPU缓存对数组友好而对链表不友好"></a>CPU缓存对数组友好而对链表不友好</h3><p>数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，每一次CPU在读取内存中的数组时不是单纯的只读取某个特定的访问地址，而是读取一个<font color="red">数据块</font>（视情况而定的一段连续的内存地址），并保存到CPU的缓存中，下次访问时就会先从CPU缓存中查找，为的就是弥补CPU速度过快而内存过慢导致的速度差异。</p><p>对于数组和链表两种数据结构，由于数组是一块连续的内存空间，<font color="red">在读取某个下标的数据时CPU就会缓存连续的几个元素加载到缓存中，</font>而链表不是连续的，链表的节点是分散在堆空间（内存）里面,CPU缓存帮不上忙，这样数组执行速度会快于存储空间不连续的链表存储，理论上CPU访问数组比链表快了大约33倍</p><p>因此，程序中尽量使用连续的数据结构，这样可以充分发挥CPU缓存的威力。 这种对缓存友好的算法称为 <font color="red">Cache-oblivious algorithm</font></p>]]></content>
      
      
      <categories>
          
          <category> 缓存机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 链表 </tag>
            
            <tag> CPU缓存 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
