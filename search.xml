<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Oracle导出导入dum文件</title>
      <link href="/2020/08/05/oracle-dao-chu-dao-ru-dum-wen-jian/"/>
      <url>/2020/08/05/oracle-dao-chu-dao-ru-dum-wen-jian/</url>
      
        <content type="html"><![CDATA[<h3 id="Oracle导入导出dum文件"><a href="#Oracle导入导出dum文件" class="headerlink" title="Oracle导入导出dum文件"></a>Oracle导入导出dum文件</h3><p>一、创建用户并赋予权限</p><pre><code>1.create user test identified by test2.grant connect,resource,dba to test3.grant all privileges to test</code></pre><p>二、oracle备份数据<br>安装oracle客户端生辰exp imp文件才能进行导入导出<br>EXP导出是表数据为空则不会导出该表<br>1.解决方案</p><pre><code>（1）.select &#39;alter table &#39;||table_name||&#39; allocate extent;&#39; from user_tables where num_rows=0;（2）.将查询结果复制执行即可</code></pre><p>2.dmp 方式导出<br>用户方式导出</p><pre><code>EXP test/test@orcl BUFFER=64000 FILE=D:\test.dmp OWNER=test log=D:\test.logEXP test/test@192.168.100.183:1521/xe BUFFER=64000 FILE=D:\test.dmp OWNER=test log=D:\test.log</code></pre><p>用户方式导入</p><pre><code>IMP test/test@orcl BUFFER=64000 FILE=D:\test.dmp FROMUSER=test TOUSER=test01 log=D:\test.logIMP test/test@192.168.100.183:1521/xe BUFFER=64000 FILE=D:\test.dmp FROMUSER=test TOUSER=test01 log=D:\test.logimp test/test@192.168.1.100:1521/orcl full=y file=C:test.dmp</code></pre><p>exp三种用法：</p><p>1、exp 导出某个用户全部数据库</p><p>格式：exp ywxy/ywxy@ORCL file=d:/daochu1.dmp full=y;</p><p>ywxy/ywxy@ORCL  是用户名/密码@数据库名</p><p>file=d:/daochu1.dmp  是导出的路径</p><p>full=y 是导出全库</p><p>2、exp 导出某个用户的某个库</p><p>格式：exp ywxy/ywxy@ORCL file=d:/daochu1.dmp owner=system;</p><p>ywxy/ywxy@ORCL  是用户名/密码@数据库名</p><p>file=d:/daochu1.dmp  是导出的路径</p><p>owner=system 是要导出的库</p><p>3、exp 导出某个用户的某个表</p><p>格式：exp ywxy/ywxy@ORCL file=d:/daochu1.dmp tables=C_ZX_QYJC;</p><p>ywxy/ywxy@ORCL  是用户名/密码@数据库名</p><p>file=d:/daochu1.dmp  是导出的路径</p><p>tables=C_ZX_QYJC  是导出的表名字，多个表名则 (table1,table2)形式</p><p>扩展资料：</p><p>常用选项：</p><p>1、FULL，用于导出整个数据库，在ROWS=N一起使用时，可以导出整个数据库的结构。</p><p>2、OWNER和TABLE，这两个选项用于定义EXP的对象。OWNER定义导出指定用户的对象，TABLE指定EXP的table名称。</p><p>⒊BUFFER和FEEDBACK，在导出比较多的数据时，考虑设置这两个参数。</p><p>⒋FILE和LOG，这两个参数分别指定备份的DMP名称和LOG名称，包括文件名和目录。</p><p>⒌COMPRESS参数不压缩导出数据的内容。用来控制导出对象的storage语句如何产生。默认7a686964616fe4b893e5b19e31333431373264值为Y，使用默认值，对象的存储语句的init extent等于当前导出对象的extent的总和。推荐使用COMPRESS=N。</p><p>⒍ FILESIZE该选项在8i中可用。如果导出的dmp文件过大时，最好使用FILESIZE参数，限制文件大小不要超过2G。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
            <tag> dum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次oracle存储过程中的异常处理</title>
      <link href="/2020/08/05/ji-yi-ci-oracle-cun-chu-guo-cheng-zhong-de-yi-chang/"/>
      <url>/2020/08/05/ji-yi-ci-oracle-cun-chu-guo-cheng-zhong-de-yi-chang/</url>
      
        <content type="html"><![CDATA[<h3 id="Oracle中存储过程的异常处理"><a href="#Oracle中存储过程的异常处理" class="headerlink" title="Oracle中存储过程的异常处理"></a>Oracle中存储过程的异常处理</h3><ul><li>调用存储过程时抛出异常 no data found<br>经过调试存储过程发现是由于存储过程中一条类似如下的sql报错<pre><code>select id into value from test where id =1</code></pre>原因：test表中不存在id =1的记录，在给value赋值时抛出no data found</li></ul><p>解决方案：</p><pre><code> select count(*) into idCount from test where id =1</code></pre><p>判断idCount是否大于0</p><pre><code>        IF        idCount &gt; 0 THEN        //操作        end if</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
            <tag> 存储过程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树</title>
      <link href="/2020/07/23/red-black-tree/"/>
      <url>/2020/07/23/red-black-tree/</url>
      
        <content type="html"><![CDATA[<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>1.什么是红黑树</p><p>红黑树是一种平衡的二叉查找树，能够保证在最坏的情况下动态集合操作的时间复杂度为O(logN),红黑树每个节点包括五个域，分别为left、right、parent、color、key。</p><p>2.红黑树的特征</p><ul><li>每个节点不是红色就是黑色</li><li>不可能有连在一起的红色</li><li>根节点都是黑色</li><li>每个红色节点的两个子节点都是黑色，叶子节点(NIL)都是黑色：出度为0，满足了性质就可以近似平衡。</li><li>黑高度：从某个结点x出发（不包括该结点）到达一个叶结点的任意一条路径上，黑色结点的个数称为该结点x的黑高度。</li><li>一颗有n个内结点的红黑树的高度至多为2lg(n+1)。（内结点视为红黑树中带关键字的结点）</li><li>包含n个内部节点的红黑树的高度是O(log(n))。</li></ul><p>3.红黑树的旋转和颜色变换</p><ul><li>变颜色：当前节点是红色，父节点以及叔叔节点是红色</li></ul><p>(1).把父节点设置为黑色<br>(2).把叔叔节点设置为黑色<br>(3).把爷爷节点设置为红色<br>(4).把指针定义到爷爷节点设为当前要操作的节点</p><ul><li>左旋：当前节点的父节点为红色，叔叔节点为黑色时，且当前节点为右子树，则进行左旋</li><li>右旋：当前节点的父节点为红色，叔叔节点为黑色时，且点前节点为左子树，则进行右旋<br>(1).把父节点设置为黑色<br>(2).把爷爷节点设置为红色<br>(3).以爷爷节点旋转</li></ul>]]></content>
      
      
      <categories>
          
          <category> 红黑树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql索引原理</title>
      <link href="/2020/07/23/mysql-index/"/>
      <url>/2020/07/23/mysql-index/</url>
      
        <content type="html"><![CDATA[<h3 id="一、什么是索引？"><a href="#一、什么是索引？" class="headerlink" title="一、什么是索引？"></a>一、什么是索引？</h3><ul><li>索引就好比一本书的目录，它能让你更快的找到自己想要的内容。</li><li>让获取的数据更有目的性，从而提高数据库检索数据的性能。<h3 id="二、索引方法"><a href="#二、索引方法" class="headerlink" title="二、索引方法"></a>二、索引方法</h3></li><li>BTREE:B+树索引 ( Btree B+tree B*tree)</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;B-Tree是最常见的索引类型，所有的列都是排序过的，每个叶节点跟节点距离相等。</p><ul><li>HASH：HASH索引 (hash key)</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;1.仅支持”=”,”IN”和”&lt;=&gt;”精确查询，不能使用范围查询：<br>由于Hash索引比较的是进行Hash运算之后的Hash值，所以它只能用于等值的过滤，不能用于基于范围的过滤。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;2.不支持排序：<br>由于Hash索引中存放的是经过Hash计算之后的Hash值，而且Hash值的大小关系并不一定和Hash运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算</p><p>&nbsp;&nbsp;&nbsp;&nbsp;3.在任何时候都不能避免行读取：<br>由于Hash索引比较的是进行Hash运算之后的Hash值，所以即使取满足某个Hash键值的数据的记录条数，也无法从Hash索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;4.检索效率高，索引的检索可以一次定位，不像B-Tree索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以Hash索引的查询效率要远高于B-Tree索引</p><p>&nbsp;&nbsp;&nbsp;&nbsp;5.只有Memory引擎支持显式的Hash索引，但是它的Hash是nonunique的，冲突太多时也会影响查找性能。Memory引擎默认的索引类型即是Hash索引，虽然它也支持B-Tree索引，Innodb不能显示的定义Hash索引，称为自适应Hash,Innodb存储引擎会根据表的使用情况自动为表生成Hash索引，不能认为的干预是否在一张表中生成Hash索引。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;当Innodb注意到某些索引值被使用得非常频繁的时候，它会在内存中基于B-Tree索引之上再创建一个Hash索引，这样让B-Tree也具有Hash索引的一些优点，比如快速查找，时间复杂度为O(1)</p><ul><li>R_Tree索引</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;R-Tree在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。</p><p>相对于b-tree，r-tree的优势在于范围查找。</p><ul><li>full-text索引</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;full-text在mysql里仅有myisam支持它，InnoDB引擎对FULLTEXT索引的支持是MySQL5.6新引入的特性，而且支持full-text的字段只有char、varchar、text数据类型。full-text主要是用来代替like “%***%”效率低下的问题</p><h3 id="三、索引类型"><a href="#三、索引类型" class="headerlink" title="三、索引类型"></a>三、索引类型</h3><ul><li>主键索引 是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引。</li><li>普通索引 最基本的索引，它没有任何限制，用于加速查询。</li><li>唯一索引 索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</li><li>组合索引 指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合。</li><li>全文索引 主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text列上可以创建全文索引。对文本的内容进行分词，进行搜索 </li></ul><p><font color="red">小结：虽然索引可以增加查询数据，但对于更新、创建或者删除的时候，需要去维护索引，导致性能会受影响，因此，索引也不能建立太多。<br></font><br>1.创建索引</p><p>alter table test01 add index idx_name(name);</p><p>create index index_name on test01(name);</p><p>2.删除索引</p><p>alter table test drop key index_name;</p><p>3.查看索引</p><pre><code>desc test01;show index from test01;show create table test01;</code></pre><h3 id="四、索引数据结构"><a href="#四、索引数据结构" class="headerlink" title="四、索引数据结构"></a>四、索引数据结构</h3><p><font color="red">问题:为什么mysql中采用B+树作为索引数据结构？</font><br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" title="标题" target="_blank" rel="noopener">数据结构</a></p><ul><li><p>二叉树搜索树（Binary Search Tree）BST</p><p><img src="https://yt-1300603068.cos.ap-chengdu.myqcloud.com/souyin1.png" alt="二叉树"></p><!--![二叉搜索树（二叉排序树）](https://yt-1300603068.cos.ap-chengdu.myqcloud.com/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%EF%BC%89.png)--><p>&nbsp;&nbsp;&nbsp;&nbsp;二叉树搜索树的特点</p></li><li><p>所有结点至多拥有两个儿子（Left和Right）；</p></li><li><p>所有结点只存储一个关键字（可以理解为索引，比如ID值）；</p></li><li><p>非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；</p></li><li><p>二叉搜索树如果是满二叉树时，查找的性能逼近有序数组的二分查找，同时插入的性能远远高于有序数组，因为只需要再对应的节点添加引用，而不需要移动任何老的节点</p><!--![失衡二叉排序树](https://yt-1300603068.cos.ap-chengdu.myqcloud.com/%E5%A4%B1%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91.png)--></li></ul><ul><li>AVL树和红黑树</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;1.AVL:自平衡二叉查找树，解决二叉树不平衡问题，在插入和删除时通过节点的自旋来让二叉树保持平衡，AVL追求极致的平衡。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;同样红黑树相比平衡二叉树的极致平衡红黑树只追求大致的平衡，保证每次插入最多只需要三次旋转就能达到平衡，红黑树保持平衡主要靠的节点颜色的变换和左旋右旋，红黑树保持了树的基本平衡，也让插入和删除产生的旋转不至于像AVL那样又太大的性能消耗，也不至于像二叉搜索树那样退化成链表，红黑树拥有不错的平均查找效率，也不存在极端的 O(n)情况。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;红黑树的特征</p><ul><li>每个节点不是红色就是黑色</li><li>不可能有连在一起的红色</li><li>根节点都是黑色</li><li>每个红色节点的两个子节点都是黑色，叶子节点(NIL)都是黑色：出度为0，满足了性质就可以近似平衡。</li><li>黑高度：从某个结点x出发（不包括该结点）到达一个叶结点的任意一条路径上，黑色结点的个数称为该结点x的黑高度。</li><li>一颗有n个内结点的红黑树的高度至多为2lg(n+1)。（内结点视为红黑树中带关键字的结点）</li><li>包含n个内部节点的红黑树的高度是O(log(n))。</li></ul><p><font color="red">&nbsp;&nbsp;&nbsp;&nbsp;为什么不采用红黑树作为Mysql底层索引结构？</font></p><p><img src="https://yt-1300603068.cos.ap-chengdu.myqcloud.com/mysql/hongheishu1.png" alt="红黑树"></p><p><img src="https://yt-1300603068.cos.ap-chengdu.myqcloud.com/mysql/hongheishu2.png" alt="红黑树"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;红黑树并没有完全解决二叉查找树这个“右倾”趋势远没有二叉查找树退化为线性链表那么夸张，但是数据库中的基本主键自增操作，主键一般都是数百万数千万的，如果红黑树存在这种问题，对于查找性能而言也是巨大的消耗，我们数据库不可能忍受这种无意义的等待的。</p><ul><li>Hash表<br><img src="https://yt-1300603068.cos.ap-chengdu.myqcloud.com/mysql/hash.png" alt="B-树"></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;哈希算法有个数据碰撞的问题，也就是哈希函数可能对不同的 key 会计算出同一个结果，比如 hash(7)可能跟 hash(199)计算出来的结果一样，也就是不同的 key 映射到同一个结果了，这就是碰撞问题。解决碰撞问题的一个常见处理方式就是链地址法，即用链表把碰撞的数据接连起来。计算哈希值之后，还需要检查该哈希值是否存在碰撞数据链表，有则一直遍历到链表尾，直达找到真正的 key 对应的数据为止。</p><p><font color="red">&nbsp;&nbsp;&nbsp;&nbsp;为什么不采用哈希表作为Mysql底层索引结构？<font></font></font></p><p><img src="https://yt-1300603068.cos.ap-chengdu.myqcloud.com/mysql/hashpengzhuang.png" alt="哈希冲突"></p><p><img src="https://yt-1300603068.cos.ap-chengdu.myqcloud.com/mysql/hashchaxun.png" alt="Mysql Hash索引"></p><ul><li>B-树 </li></ul><p><img src="https://yt-1300603068.cos.ap-chengdu.myqcloud.com/B.png" alt="B-树"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;叶子节点具有相同的深度，叶子节点的指针为空</p><p>&nbsp;&nbsp;&nbsp;&nbsp;所有元素不重复</p><p>&nbsp;&nbsp;&nbsp;&nbsp;节点中的数据索引从左到右递增排列</p><ul><li>B+树</li></ul><p><img src="https://yt-1300603068.cos.ap-chengdu.myqcloud.com/B%2B.png" alt="B+树"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;B+树的结构特点</p><ul><li>B+树索引并不能找到一个给定键值的具体行，它找到的只是被查找数据行所在的页，接着数据库会把页读入到内存，再在内存中进行查找，最后得到要查找的数据。数据的读取是精确到页的，因为页是计算机管理存储器的逻辑块，IO的磁盘读取，每次都读取数据的大小是一个页大小的整数倍。</li><li>假设B+Tree的高度为h，一次检索最多需要h-1次I/O（根节点常驻内存），复杂度O(h) = O(logmN)，m指的是一个节点存储的数据的个数。实际应用场景中，M通常较大，常常超过100，因此树的高度一般都比较小，通常不超过3。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;B+树与B树的不同在于：</p><ul><li>所有关键字存储在叶子节点，非叶子节点不存储真正的data</li><li>为所有叶子节点（左右相邻的节点之间）增加了一个链指针<br>&lt;font style</li></ul><h4 id="B-树的插入、删除操作"><a href="#B-树的插入、删除操作" class="headerlink" title="B+树的插入、删除操作"></a>B+树的插入、删除操作</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://blog.csdn.net/sunshine_lyn/article/details/82747596" title="标题" target="_blank" rel="noopener">B+树的插入和删除</a></p><p>==为什么mysql的索引使用B+树而不是B树呢？==</p><ul><li>范围查找更快，mysql是关系型数据库，经常会按照区间来访问某个索引列，B+树的叶子节点间按顺序建立了链指针，加强了区间访问性，所以B+树对索引列上的区间范围查询很友好。而B树的数据有一部分存在在非叶子节点上面，而且默认的B树的相邻的叶子节点之间是没有指针的，所以范围查找相对更慢。</li><li>降低树的高度，但是最底下一层的节点会更多，因为所有的数据都堆积在最底下一层了，用空间换速度。B+树更适合外部存储(一般指磁盘存储),由于内节点(非叶子节点)不存储data，所以一个节点可以存储更多的内节点，每个节点能索引的范围更大更精确。也就是说使用B+树单次磁盘IO的信息量相比较B树更大，IO效率更高</li></ul><h3 id="五-局部性原理"><a href="#五-局部性原理" class="headerlink" title="五.局部性原理"></a>五.局部性原理</h3><p>1.磁盘iO与预读</p><p>&nbsp;&nbsp;&nbsp;&nbsp;简单来说，磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，这个成本是访问内存的十万倍左右。因此操作系统对此做了优化：预读，每一次IO时，不仅仅把当前磁盘地址的数据加载到内存，同时也把相邻数据也加载到内存缓冲区中。因为局部预读原理说明：当访问一个地址数据的时候，与其相邻的数据很快也会被访问到。每次磁盘IO读取的数据我们称之为一页（page）。一页的大小与操作系统有关，一般为4k或者8k。这也就意味着读取一页内数据的时候，实际上发生了一次磁盘IO。<br>在mysql中一页的定义为16kb,可以进行修改的。<br> <img src="https://yt-1300603068.cos.ap-chengdu.myqcloud.com/page.png" alt="Mysql Page大小"></p><h3 id="六、Innodb-引擎和-Myisam-引擎的实现"><a href="#六、Innodb-引擎和-Myisam-引擎的实现" class="headerlink" title="六、Innodb 引擎和 Myisam 引擎的实现"></a>六、Innodb 引擎和 Myisam 引擎的实现</h3><ul><li><p>聚簇索引：Innodb的主索引采用的是聚簇索引，一个表只能有1个聚簇索引，因为表数据存储的物理位置是唯一的。聚簇索引的value存的就是真实的数据，不是数据的地址。主索引树里面包含了真实的数据。key是主键值，value值就是data，key值按照B+树的规则分散排布的叶子节点。</p></li><li><p>非聚簇索引：Myisam的主索引和辅助索引都采用的是非聚簇索引，索引和表数据是分离的，索引的value值指向的物理的存储地址。</p><p><img src="https://yt-1300603068.cos.ap-chengdu.myqcloud.com/mysql/juji.png" alt="聚集索引和非聚集索引"></p></li></ul><p> <img src="https://yt-1300603068.cos.ap-chengdu.myqcloud.com/mysql/myisam.png" alt="非聚集索引，主索引"></p><p><img src="https://yt-1300603068.cos.ap-chengdu.myqcloud.com/mysql/fuzhusuoyin.png" alt="非聚集索引辅助索引"></p><p><img src="https://yt-1300603068.cos.ap-chengdu.myqcloud.com/mysql/innodbzhusuoyin.png" alt="Innodb辅助索引"></p><p><img src="https://yt-1300603068.cos.ap-chengdu.myqcloud.com/mysql/innodbfuzhusuoyin.png" alt="Innodb辅助索引"></p><h3 id="七、mysql索引失效的一些情况"><a href="#七、mysql索引失效的一些情况" class="headerlink" title="七、mysql索引失效的一些情况"></a>七、mysql索引失效的一些情况</h3><p>1.使用多列作为索引，则需要遵循最左前缀匹配原则（查询从索引的最左前列开始并且不跳过索引中的列）</p><p>2.不再索引列上做任何操作，例如（计算，函数，（自动 or 手动的类型转换）），会导致索引失效而转向全表扫描</p><p>3.尽量使用覆盖索引（之访问索引列的查询），减少select *,覆盖索引能减少回表次数；</p><p>4.mysql再使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描</p><p>5.like以通配符开头（%abc） mysql索引会失效变成全表扫描的操作；</p><p>6.字符串不加单引号会导致索引失效（可能发生了索引列的隐式转换）</p><p>7.少用or，用它来连接时会索引失效。要想or条件索引不失效，则把每个列都加上索引。</p><h3 id="八、联合索引"><a href="#八、联合索引" class="headerlink" title="八、联合索引"></a>八、联合索引</h3><ul><li>联合索引又叫复合索引。两个或更多个列上的索引被称作复合索引。</li><li>如 b c d三个字段建立联合索引</li></ul><p>1.全值匹配</p><pre><code>select * from test where b = 1 and c = 1 and d = 1;select * from test where c = 1 and b = 1 and  d = 1;select * from test where d = 1 and b = 1 and  c = 1;b = 1 AND c = 2 ; b = 1 AND d = 3 ; c = 1 AND b = 2 ; </code></pre><h6 id="不包含最左侧的-b"><a href="#不包含最左侧的-b" class="headerlink" title="不包含最左侧的 b"></a>不包含最左侧的 b</h6><pre><code>c = 3 ; d = 2 ; d = 2 AND c = 3 ; c = 1 AND d = 2 ; </code></pre><h6 id="OR"><a href="#OR" class="headerlink" title="OR"></a>OR</h6><pre><code>b = 1 AND c = 2 OR d = 3 b = 1 OR c = 2 AND d = 3 b = 1 OR c = 2 OR d = 3 </code></pre><h6 id="最左侧的‘a’列-被大于，小于，不等于比较"><a href="#最左侧的‘a’列-被大于，小于，不等于比较" class="headerlink" title="最左侧的‘a’列 被大于，小于，不等于比较"></a>最左侧的‘a’列 被大于，小于，不等于比较</h6><pre><code>b &gt; 1 AND c = 2 AND d = 3  b &lt; 1 AND c =  2 AND d = 3  b &gt; 1 b &lt;&gt; 1 AND c = 2 AND d = 3 </code></pre><h6 id="最左侧b-某某"><a href="#最左侧b-某某" class="headerlink" title="最左侧b=某某"></a>最左侧b=某某</h6><pre><code>b = 1 AND c &lt; 2 AND d = 3 b = 1 AND d = 2 AND c &lt; 3 b = 1 AND c &lt; 2 b = 1 AND c &lt;&gt; 2 AND d = 3 b = 1 AND c &lt; 2 OR d = 2 </code></pre><p>2.匹配左边的列</p><pre><code>select * from t1 where b = 1;select * from t1 where b = 1 and c = 1;</code></pre><p>下面这个sql可以用到索引吗？</p><pre><code> select * from t1 where c = 1;</code></pre><p> 因为B+树先是按照b列的值排序的，在b列的值相同的情况下才使用c列进行排序，也就是说b列的值不同的记录<br>中c的值可能是无序的。而现在你跳过b列直接根据c的值去查找，这是做不到的。</p><p>3.匹配列前缀</p><pre><code>select * from t1 where b like &#39;%101%&#39;;</code></pre><p>这种是用不到索引的，因为字符串中间有’101’的字符串并没有排好序，所以只能全表扫描了。有时候我们有一些<br>匹配某些字符串后缀的需求，比方说某个表有一个url列，该列中存储了许多url：</p><pre><code>www.baidu.comwww.google.comwww.qq.com</code></pre><pre><code>moc.udiab.wwwmoc.elgoog.wwwmoc.qq.www</code></pre><p>这样再查找以com为后缀的网址时搜索条件便可以这么写：WHERE url LIKE ‘moc%’，这样就可以用到索引了。</p><p>4.匹配范围值</p><pre><code>select * from t1 where b &gt; 1 and b &lt; 20000;</code></pre><p>由于B+树中的数据页和记录是先按b列排序的，所以我们上边的查询过程其实是这样的：<br>找到b值为1的记录。<br>找到b值为20000的记录。<br>由于所有记录都是由链表连起来的（记录之间用单链表，数据页之间用双链表），所以他们之间的<br>记录都可以很容易的取出来<br>找到这些记录的主键值，再到聚簇索引中回表查找完整的记录。<br>不过在使用联合进行范围查找的时候需要注意，如果对多个列同时进行范围查找的话，只有对索引最左边的那个<br>列进行范围查找的时候才能用到B+树索引，比如：</p><pre><code>select * from t1 where b &gt; 1 and c &gt; 1;</code></pre><p>上边这个查询可以分成两个部分：</p><ol><li>通过条件b &gt; 1来对b进行范围，查找的结果可能有多条b值不同的记录，</li><li>对这些b值不同的记录继续通过c &gt; 1继续过滤。</li><li>这样子对于联合索引来说，只能用到b列的部分，而用不到c列的部分，因为只有b值相同的情况下才能用c列的值<br>进行排序，而这个查询中通过b进行范围查找的记录中可能并不是按照c列进行排序的，所以在搜索条件中继续以<br>c列进行查找时是用不到这个B+树索引的。</li></ol><p>5.精确匹配某一列并范围匹配另一列</p><p>对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精<br>确查找，则右边的列可以进行范围查找，比方说这样：</p><pre><code>select * from t1 where b = 1 and c &gt; 1;</code></pre><p>6.排序</p><pre><code>select * from t1 order by b, c, d;</code></pre><p>这个查询的结果集需要先按照b值排序，如果记录的b值相同，则需要按照c来排序，如果c的值相同，则需要按照<br>d排序。因为这个B+树索引本身就是按照上述规则排好序的，所以直接从索引中提取数据，然后进行回表操作取<br>出该索引中不包含的列就好了。</p><p>7.分组</p><pre><code>select b, c, d, count(*) from t1 group by b, c, d;</code></pre><p>这个查询语句相当于做了3次分组操作：</p><ol><li>先把记录按照b值进行分组，所有b值相同的记录划分为一组。</li><li>将每个b值相同的分组里的记录再按照c的值进行分组，将title值相同的记录放到一个分组里。</li><li>再将上一步中产生的分组按照d的值分成更小的分组。<br>如果没有索引的话，这个分组过程全部需要在内存里实现，而如果有索引的话，正好这个分组顺序又和B+树中的<br>索引列的顺序是一致的，所以可以直接使用B+树索引进行分组。</li></ol><p>使用联合索引进行排序和分组的注意事项</p><p>1.对于联合索引有个问题需要注意，ORDER BY的子句后边的列的顺序也必须按照索引列的顺序给出，如果给出order by c, b, d 的顺序，那也是用不了B+树索引的。</p><p>同理， order by b҅order by b, c 这种匹配索引左边的列的形式可以使用部分的B+树索引。当联合索引<br>左边列的值为常量，也可以使用后边的列进行排序，比如这样：</p><pre><code>select * from t1 where b = 1 order by c, d;</code></pre><p>不可以使用索引进行排序或分组的情况</p><h5 id="ASC和DESC混用"><a href="#ASC和DESC混用" class="headerlink" title="ASC和DESC混用"></a>ASC和DESC混用</h5><pre><code>select * from t1 order by b ASC, c DESC;</code></pre><p>这个查询是使用不到索引的。</p><h3 id="九、覆盖索引"><a href="#九、覆盖索引" class="headerlink" title="九、覆盖索引"></a>九、覆盖索引</h3><pre><code>select * from t1 where b between 3 and 5;</code></pre><p>这条SQL语句的执行流程如下：</p><p>在 b 索引树上找到 b=3 的记录，取得 id = 3；<br>再到 id 索引树查到 id=1 对应的记录；<br>在 b 索引树取下一个值 b=5，取得 id=5；<br>再回到 id 索引树查到 ID=5 对应的记录；<br>在 b 索引树取下一个值b=6，不满足条件，循环结束。</p><p>在这个过程中，回到主键索引树的过程，称为回表。在这个例子中，由于查询的结果是所有字段，所需要的数据只有主键上才有，所以不得不回表。但如果执行的语句是下面这样的，注意！这里查询的结果只是“id”（恰好是主键），而不是所有字段了。</p><pre><code>select id from t1 where b between 3 and 5;</code></pre><p>由于查询的值是id，而id的值已经在b索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里，索引k已经“覆盖了”我们的查询需求，故称为覆盖索引。</p><h5 id="覆盖索引对于统计的优化"><a href="#覆盖索引对于统计的优化" class="headerlink" title="覆盖索引对于统计的优化"></a>覆盖索引对于统计的优化</h5><pre><code>SELECT count(*) from test</code></pre><p>假如test表只有id和name两个字段，id为主键，name不建立索引，那么统计的时候查询优化器会根据id操作，假如name建立索引，查询优化器优先选用辅助索引。</p><p>因为聚集索引和辅助索引的区别，聚集索引中存储的是整行记录，辅助索引中存储的是主键值，所以辅助索引树中的一页可以存储更多的辅助索引，从而减少磁盘io。</p><p>总结：覆盖索引就是从辅助索引中就能直接得到查询结果，而不需要回表到聚簇索引中进行再次查询，所以可以减少搜索次数（不需要从辅助索引树回表到聚簇索引树），或者说减少IO操作（通过辅助索引树可以一次性从磁盘载入更多节点），从而提升性能。</p><h3 id="十、索引下推"><a href="#十、索引下推" class="headerlink" title="十、索引下推"></a>十、索引下推</h3><ul><li>什么是索引下推（Index Condition Pushdown，ICP）呢？假设有这么个需求，查询表中“名字第一个字是张，年龄为10岁的所有记录”。那么，查询语句是这么写的：</li></ul><pre><code>select * from tuser where name like &#39;张 %&#39; and age=10 and ismale=1;</code></pre><p>根据“最左前缀原则”，该语句在搜索索引树的时候，只能匹配到名字第一个字是‘张’的记录（即记录ID3），接下来是怎么处理的呢？当然就是从ID3开始，逐个回表，到主键索引上找出相应的记录，再比对age和ismale这两个字段的值是否符合。</p><p>但是！MySQL5.6引入了索引下推优化，可以在索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表字数。</p><p><img src="https://yt-1300603068.cos.ap-chengdu.myqcloud.com/mysql/suoyin/suoyinxiatui1.jpg" alt="索引下推"></p><p><img src="https://yt-1300603068.cos.ap-chengdu.myqcloud.com/mysql/suoyin/suoyinxiatui2.jpg" alt="索引下推"></p><h3 id="九、如何建立索引？"><a href="#九、如何建立索引？" class="headerlink" title="九、如何建立索引？"></a>九、如何建立索引？</h3><ul><li>考虑索引选择性</li></ul><p>索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数的比值：<br>基数又叫索引基数，是数据列所包含的不同值的数量。</p><pre><code>选择性=基数/记录数</code></pre><p>选择性的取值范围为(0, 1]，选择性越高的索引价值越大。如果选择性等于1，就代表这个列的不重复值和表记录<br>数是一样的，那么对这个列建立索引是非常合适的，如果选择性非常小，那么就代表这个列的重复值是很多的，<br>不适合建立索引</p><p>例如，某个数据列包含值1、3、7、4、7、3，那么它的基数就是4。</p><p>索引基数越大，工作效率越好。</p><p>如果某个索引所在的数据列含有很多不同年龄，索引会快速分辨数据行。</p><p>如果某个索引所在的数据列只记录性别(man或者woman)，那么索引的用处就不大。</p><p>如果值出现的机率几乎相等，那么无论搜索哪个值都可能得到一半的数据行。在这些情况下，最好不要使用索引，<br>因为查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一半会忽略索引，进行全表扫描。惯用的百分比界限是30%。(匹配的数据量超过一定限制的时候查询器会放弃使用索引。尽量不使用会导致索引失效的条件，</p><p>比如in，用exists子查询代替，或者in的条件少时可以用union all代替)</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li>索引列的类型尽量小</li><li>利用索引字符串值的前缀</li><li>主键自增</li><li>定位并删除表中的重复和冗余索引</li><li>尽量使用覆盖索引进行查询，避免回表带来的性能损耗。</li></ul><h3 id="常见优化手段"><a href="#常见优化手段" class="headerlink" title="常见优化手段"></a>常见优化手段</h3><ol><li>SQL语句中IN包含的值不应过多，不能超过200个，200个以内查询优化器计算成本时比较精准，超过200<br>个是估算的成本，另外建议能用between就不要用in，这样就可以使用range索引了。</li><li>SELECT语句务必指明字段名称：SELECT * 增加很多不必要的消耗（cpu、io、内存、网络带宽）；增加<br>了使用覆盖索引的可能性；当表结构发生改变时，前断也需要更新。所以要求直接在select后面接上字段名。</li><li>当只需要一条数据的时候，使用limit 1</li><li>排序时注意是否能用到索引</li><li>使用or时如果没有用到索引，可以改为union all 或者union</li><li>如果in不能用到索引，可以改成exists看是否能用到索引</li><li>使用合理的分页方式以提高分页的效率</li><li>不建议使用%前缀模糊查询</li><li>避免在where子句中对字段进行表达式操作</li><li>避免隐式类型转换</li><li>对于联合索引来说，要遵守最左前缀法则</li><li>必要时可以使用force index来强制查询走某个索引</li><li>对于联合索引来说，如果存在范围查询，比如between,&gt;,&lt;等条件时，会造成后面的索引字段失效。</li><li>尽量使用inner join，避免left join，让查询优化器来自动选择小表作为驱动表</li><li>必要时刻可以使用straight_join来指定驱动表，前提条件是本身是inner join</li></ol>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
          <category> 索引 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring IOC和AOP</title>
      <link href="/2020/07/07/spring-ioc-he-aop/"/>
      <url>/2020/07/07/spring-ioc-he-aop/</url>
      
        <content type="html"><![CDATA[<h3 id="Spring-IOC和AOP的原理及相关面试题"><a href="#Spring-IOC和AOP的原理及相关面试题" class="headerlink" title="Spring IOC和AOP的原理及相关面试题"></a>Spring IOC和AOP的原理及相关面试题</h3><h4 id="1-什么是IOC和DI-有什么区别？"><a href="#1-什么是IOC和DI-有什么区别？" class="headerlink" title="1.什么是IOC和DI?有什么区别？"></a>1.什么是IOC和DI?有什么区别？</h4><p>控制反转(Ioc)：它不是技术，而是一种思想，将创建对象的控制权力交给spring框架。由Spring来负责控制对象的生命周期和对象间的关系，其核心是通过反射调用set方法来进行数据的注入。<br>依赖注入(DI)：指Spring创建对象的过程中，将对象依赖的属性（简单值，集合，对象）通过配置的方式进行设值。<br>IoC和DI其实是同一个概念的不同角度描述，DI相对IoC而言，明确描述了被管理的对象中，依赖的属性也应该由Spring容器自动注入</p><h4 id="2-IOC容器的初始化过程"><a href="#2-IOC容器的初始化过程" class="headerlink" title="2.IOC容器的初始化过程?"></a>2.IOC容器的初始化过程?</h4><p>(1).BeanDefinition的Resource定位<br>Resource，对资源的抽象，它的每一个实现类都代表了一种资源的访问策略，如ClasspathResource 、 URLResource ，FileSystemResource 等。<br>(2).BeanDefinition的载入<br>(3).向IoC容器注册BeanDefinition<br>IOC容器的初始化过程，一般不包含bean的依赖注入的实现，在spring IOC设计中，bean的注册和依赖注入是两个过程，，依赖注入一般发生在应用第一次索取bean的时候，但是也可以在xm中配置，在容器初始化的时候，这个bean就完成了初始化。</p><h4 id="3-bean如何创建？"><a href="#3-bean如何创建？" class="headerlink" title="3.bean如何创建？"></a>3.bean如何创建？</h4><p>(1)xml文件<br>(2)Spring4.x的javaConfig方式<br>// 创建一个类，命名为SpringConfiguration</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringConfiguration</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"singleton"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Student <span class="token function">student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token string">"jack"</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-注入方式有哪几种？"><a href="#4-注入方式有哪几种？" class="headerlink" title="4.注入方式有哪几种？"></a>4.注入方式有哪几种？</h4><p>构造方法注入<br>setter注入<br>基于注解注入（常用）</p><h4 id="5-springIOC-bean的生命周期？"><a href="#5-springIOC-bean的生命周期？" class="headerlink" title="5.springIOC bean的生命周期？"></a>5.springIOC bean的生命周期？</h4><p> <img src="shengMingZhouQi.jpg" alt="Bean的生命周期"></p><p>1.实例化 Instantiation InstantiationAwareBeanPostProcessor </p><p>2.属性赋值 Populate</p><p>3.初始化 Initialization BeanPostProcessor</p><p>4.销毁 Destruction<br>在配置bean时，通过init-method和destroy-method 属性为bean指定初始化和销毁方法</p><h4 id="6-常用的扩展接口"><a href="#6-常用的扩展接口" class="headerlink" title="6.常用的扩展接口"></a>6.常用的扩展接口</h4><p> (1).Aware 接口为 Spring 容器的核心接口，是一个具有标识作用的超级接口，实现了该接口的 bean 是具有被 Spring 容器通知的能力，通知的方式是采用回调的方式。<br>** BeanNameAware：对该 bean 对象定义的 beanName 设置到当前对象实例中<br>** BeanClassLoaderAware：将当前 bean 对象相应的 ClassLoader 注入到当前对象实例中<br>** BeanFactoryAware：BeanFactory 容器会将自身注入到当前对象实例中，这样当前对象就会拥有一个 BeanFactory 容器的引用。<br>** LoadTimeWeaverAware：加载Spring Bean时织入第三方模块，如AspectJ<br>** BootstrapContextAware：资源适配器BootstrapContext，如JCA,CCI<br>** ResourceLoaderAware：底层访问资源的加载器<br>** PortletConfigAware：PortletConfig<br>** PortletContextAware：PortletContext<br>** ServletConfigAware：ServletConfig<br>** ServletContextAware：ServletContext<br>**  MessageSourceAware：国际化<br>** ApplicationEventPublisherAware：应用事件<br>** NotificationPublisherAware：JMX通知<br>(2).BeanPostProcessor<br>初始化第二个阶段则是 BeanPostProcessor 增强处理，在该阶段 BeanPostProcessor 会处理当前容器内所有符合条件的实例化后的 bean 对象。<br>它主要是对 Spring 容器提供的 bean 实例对象进行有效的扩展，允许 Spring 在初始化 bean 阶段对其进行定制化修改，如处理标记接口或者为其提供代理实现。<br>(3).InitializingBean 和 init-method<br>InitializingBean 是一个接口，它为 Spring Bean 的初始化提供了一种方式，它有一个 afterPropertiesSet() 方法，<br>在 bean 的初始化进程中会判断当前 bean 是否实现了 InitializingBean，如果实现了则调用 afterPropertiesSet() 进行初始化工作。然后再检查是否也指定了 init-method()，如果指定了则通过反射机制调用指定的 init-method()。<br>(4).DisposableBean 和 destroy-method<br>与 InitializingBean 和 init-method 用于对象的自定义初始化工作相似，DisposableBean和 destroy-method 则用于对象的自定义销毁工作。<br>当一个 bean 对象经历了实例化、设置属性、初始化阶段,那么该 bean 对象就可以供容器使用了（调用的过程）。<br>当完成调用后，如果是 singleton 类型的 bean ，则会看当前 bean 是否应实现了 DisposableBean 接口或者配置了 destroy-method 属性，如果是的话，则会为该实例注册一个用于对象销毁的回调方法，便于在这些 singleton 类型的 bean 对象销毁之前执行销毁逻辑。<br>但是，并不是对象完成调用后就会立刻执行销毁方法，因为这个时候 Spring 容器还处于运行阶段，只有当 Spring 容器关闭的时候才会去调用。但是， Spring 容器不会这么聪明会自动去调用这些销毁方法，而是需要我们主动去告知 Spring 容器。<br>对于 BeanFactory 容器而言，我们需要主动调用 destroySingletons() 通知 BeanFactory 容器去执行相应的销毁方法。<br>对于 ApplicationContext 容器而言调用 registerShutdownHook() 方法。</p><h4 id="7-数据是如何注入的？"><a href="#7-数据是如何注入的？" class="headerlink" title="7.数据是如何注入的？"></a>7.数据是如何注入的？</h4><p>其核心是通过反射进行数据的注入</p><h4 id="8-BeanFactory和FactoryBean的区别？"><a href="#8-BeanFactory和FactoryBean的区别？" class="headerlink" title="8.BeanFactory和FactoryBean的区别？"></a>8.BeanFactory和FactoryBean的区别？</h4><p>(1)都是接口<br>(2)BeanFactory是一个工厂类，用于管理Bean的一个工厂，在Spring中所有的Bean都是由BeanFactory（就是IOC容器）管理。</p><p>FactoryBean这个Bean不是简单的Bean，而是一个能生产或者修饰对象生成的工厂Bean,它的实现与设计模式中的工厂模式和修饰器模式类似。<br>一般情况下，Spring通过反射机制利用<bean>的class属性指定实现类实例化Bean，在某些情况下，实例化Bean过程比较复杂，<br>如果按照传统的方式，则需要在<bean>中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。<br>Spring为此提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。<br>FactoryBean接口对于Spring框架来说占用重要的地位，Spring自身就提供了70多个FactoryBean的实现。<br>它们隐藏了实例化一些复杂Bean的细节，给上层应用带来了便利。从Spring3.0开始，FactoryBean开始支持泛型，即接口声明改为FactoryBean<t>的形式<br>利用反射</t></bean></bean></p><h4 id="9-Bean生命周期中循环依赖如何解决？"><a href="#9-Bean生命周期中循环依赖如何解决？" class="headerlink" title="9.Bean生命周期中循环依赖如何解决？"></a>9.Bean生命周期中循环依赖如何解决？</h4><h4 id="10-什么是AOP"><a href="#10-什么是AOP" class="headerlink" title="10.什么是AOP?"></a>10.什么是AOP?</h4><p>面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术，<br>可以在正常的业务逻辑中进行横切，从而使得业务逻辑的各部分之间的耦合度降低，提高程序的可重用性，提高开发效率。<br> <img src="aop.png" alt="AOP"><br>(1)Aspect 切面 通常是一个类，里面可以定义切入点和通知<br>(2)Join point 程序执行过程中明确的点，一般是方法的调用。被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器<br>(3)Advice AOP在特定的切入点上执行的增强处理，<br>before(前置)<br>after(后置)<br>afterReturning(最终)<br>afterThrowing(异常)<br>around(环绕)<br>(4)Pointcut 就是带有通知的连接点，在程序中主要体现为书写切入点表达式<br>(5)weave 将切面应用到目标对象并导致代理对象创建的过程<br>(6)introduction 在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段<br>(7)ProxyAOP框架创建的对象，代理就是目标对象的加强。Spring中的AOP代理可以使JDK动态代理，也可以是CGLIB代理，前者基于接口，后者基于子类<br>(8)Target 包含连接点的对象。也被称作被通知或被代理对象。</p><h4 id="11-Spring-AOP是基于那种设计模式？"><a href="#11-Spring-AOP是基于那种设计模式？" class="headerlink" title="11.Spring AOP是基于那种设计模式？"></a>11.Spring AOP是基于那种设计模式？</h4><p>代理模式</p><h4 id="12-什么是代理模式？"><a href="#12-什么是代理模式？" class="headerlink" title="12.什么是代理模式？"></a>12.什么是代理模式？</h4><p>给某个对象提供一个代理对象，并且有代理对象控制对原对象的引用<br>Subject：抽象主题角色。可以是抽象类也可以是接口，是一个最普通的业务类型定义。<br>RealSubject：具体主题角色，也就是被代理的对象，是业务逻辑的具体执行者。<br>Proxy：代理主题角色。负责读具体主题角色的引用，通过真实角色的业务逻辑方法来实现抽象方法，并在前后可以附加自己的操作。<br> <img src="dailimoshi.png" alt="代理模式"></p><h4 id="13-静态代理和动态代理有什么区别？"><a href="#13-静态代理和动态代理有什么区别？" class="headerlink" title="13.静态代理和动态代理有什么区别？"></a>13.静态代理和动态代理有什么区别？</h4><p>静态代理：由程序员创建或由特定工具自bai动生成源代码du，再对其编译。在程序运行前，代理类的.class文件就已经存在了。动态代理类：在程序运行时，运用反射机制动态创建而成。<br>缺点：<br>(1)代理类和委托类实现了相同的接口，代理类通过委托类实现了相同的方法。这样就出现了大量的代码重复。如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。</p><p>(2)代理对象只服务于一种类型的对象，如果要服务多类型的对象。势必要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。如上的代码是只为UserManager类的访问提供了代理，但是如果还要为其他类如Department类提供代理的话，就需要我们再次添加代理Department的代理类。<br>动态代理：与静态代理类对照的是动态代理类，动态代理类的字节码在程序运行时由Java反射机制动态生成，无需程序员手工编写它的源代码。动态代理类不仅简化了编程工作，而且提高了软件系统的可扩展性，因为Java 反射机制可以生成任意类型的动态代理类。java.lang.reflect 包中的Proxy类和InvocationHandler 接口提供了生成动态代理类的能力。</p><p>(1)getProxyClass()静态方法负责创建动态代理类</p><p>(2)newProxyInstance()静态方法负责创建动态代理类的实例<br>由Proxy类的静态方法创建的动态代理类具有以下特点:<br>动态代理类是public、final和非抽象类型的;<br>动态代理类继承了java.lang.reflect.Proxy类;<br>动态代理类的名字以”$Proxy”开头;<br>动态代理类实现getProxyClass()和newProxyInstance()方法中参数interfaces指定的所有接口;</p><h4 id="14-Spring-AOP的实现原理"><a href="#14-Spring-AOP的实现原理" class="headerlink" title="14.Spring AOP的实现原理?"></a>14.Spring AOP的实现原理?</h4><p>动态代理又分为:</p><p>(1)JDK动态代理</p><p>(2)CGLIB 动态代理<br>Spring AOP动态代理的两种模式都使用了，其核心代码实现如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultAopProxyFactory</span> <span class="token keyword">implements</span> <span class="token class-name">AopProxyFactory</span><span class="token punctuation">,</span> Serializable <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">DefaultAopProxyFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> AopProxy <span class="token function">createAopProxy</span><span class="token punctuation">(</span>AdvisedSupport config<span class="token punctuation">)</span> <span class="token keyword">throws</span> AopConfigException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//此处判断目标类是否不需要对代理策略进行优化 目标类是否Proxy类型以及目标类是否是接口 则使用JDK动态代理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>config<span class="token punctuation">.</span><span class="token function">isOptimize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>config<span class="token punctuation">.</span><span class="token function">isProxyTargetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">hasNoUserSuppliedProxyInterfaces</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">JdkDynamicAopProxy</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> targetClass <span class="token operator">=</span> config<span class="token punctuation">.</span><span class="token function">getTargetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>targetClass <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AopConfigException</span><span class="token punctuation">(</span><span class="token string">"TargetSource cannot determine target class: Either an interface or a target is required for proxy creation."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">//如果不是接口并且不是Proxy类型则使用CGLIB动态代理，否则是否JDK动态代理</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span>AopProxy<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">!</span>targetClass<span class="token punctuation">.</span><span class="token function">isInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>Proxy<span class="token punctuation">.</span><span class="token function">isProxyClass</span><span class="token punctuation">(</span>targetClass<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">ObjenesisCglibAopProxy</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">JdkDynamicAopProxy</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">hasNoUserSuppliedProxyInterfaces</span><span class="token punctuation">(</span>AdvisedSupport config<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> ifcs <span class="token operator">=</span> config<span class="token punctuation">.</span><span class="token function">getProxiedInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ifcs<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> ifcs<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> SpringProxy<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>ifcs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="12-AOP应用场景"><a href="#12-AOP应用场景" class="headerlink" title="12.AOP应用场景?"></a>12.AOP应用场景?</h4><p>Authentication 权限<br>Caching 缓存<br>Context passing 内容传递<br>Error handling 错误处理<br>Lazy loading　懒加载<br>Debugging　　调试<br>logging, tracing, profiling and monitoring　记录跟踪　优化　校准<br>Performance optimization　性能优化<br>Persistence　　持久化<br>Resource pooling　资源池<br>Synchronization　同步<br>Transactions 事务</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组和链表对于内存以及CPU的访问缓存机制</title>
      <link href="/2020/06/04/arr-cpu/"/>
      <url>/2020/06/04/arr-cpu/</url>
      
        <content type="html"><![CDATA[<h3 id="CPU缓存对数组友好而对链表不友好"><a href="#CPU缓存对数组友好而对链表不友好" class="headerlink" title="CPU缓存对数组友好而对链表不友好"></a>CPU缓存对数组友好而对链表不友好</h3><p>数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，每一次CPU在读取内存中的数组时不是单纯的只读取某个特定的访问地址，而是读取一个<font color="red">数据块</font>（视情况而定的一段连续的内存地址），并保存到CPU的缓存中，下次访问时就会先从CPU缓存中查找，为的就是弥补CPU速度过快而内存过慢导致的速度差异。</p><p>对于数组和链表两种数据结构，由于数组是一块连续的内存空间，<font color="red">在读取某个下标的数据时CPU就会缓存连续的几个元素加载到缓存中，</font>而链表不是连续的，链表的节点是分散在堆空间（内存）里面,CPU缓存帮不上忙，这样数组执行速度会快于存储空间不连续的链表存储，理论上CPU访问数组比链表快了大约33倍</p><p>因此，程序中尽量使用连续的数据结构，这样可以充分发挥CPU缓存的威力。 这种对缓存友好的算法称为 <font color="red">Cache-oblivious algorithm</font></p>]]></content>
      
      
      <categories>
          
          <category> 缓存机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 链表 </tag>
            
            <tag> CPU缓存 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
