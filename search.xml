<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring IOC和AOP</title>
      <link href="/2020/07/07/spring-ioc-he-aop/"/>
      <url>/2020/07/07/spring-ioc-he-aop/</url>
      
        <content type="html"><![CDATA[<h3 id="Spring-IOC和AOP的原理及相关面试题"><a href="#Spring-IOC和AOP的原理及相关面试题" class="headerlink" title="Spring IOC和AOP的原理及相关面试题"></a>Spring IOC和AOP的原理及相关面试题</h3><p>1.什么是IOC和DI?有什么区别？<br>控制反转(Ioc)：它不是技术，而是一种思想，将创建对象的控制权力交给spring框架。由Spring来负责控制对象的生命周期和对象间的关系，其核心是通过反射调用set方法来进行数据的注入。<br>依赖注入(DI)：指Spring创建对象的过程中，将对象依赖的属性（简单值，集合，对象）通过配置的方式进行设值。<br>IoC和DI其实是同一个概念的不同角度描述，DI相对IoC而言，明确描述了被管理的对象中，依赖的属性也应该由Spring容器自动注入<br>2.IOC容器的初始化过程?<br>(1).BeanDefinition的Resource定位<br>(2).BeanDefinition的载入<br>(3).向IoC容器注册BeanDefinition<br>IOC容器的初始化过程，一般不包含bean的依赖注入的实现，在spring IOC设计中，bean的注册和依赖注入是两个过程，，依赖注入一般发生在应用第一次索取bean的时候，但是也可以在xm中配置，在容器初始化的时候，这个bean就完成了初始化。<br>3.bean如何定义？<br>(1)xml文件<br>(2)Spring4.x的javaConfig方式<br>// 创建一个类，命名为SpringConfiguration<br>@Configuration<br>public class SpringConfiguration {<br>    @Bean<br>    @Scope(value = “singleton”)<br>    public Student student(){<br>        return new Student(11,”jack”,22);<br>    }<br>}<br>3.注入方式有哪几种？<br>构造方法注入<br>setter注入<br>基于注解注入（常用）<br>4.bean是如何创建的？<br>5.springIOC bean的生命周期？<br>1.实例化 Instantiation InstantiationAwareBeanPostProcessor<br>2.属性赋值 Populate<br>3.初始化 Initialization(可扩展) BeanPostProcessor<br>4.销毁 Destruction(可扩展)<br>① 通过构造器或工厂方法创建bean实例<br>② 为bean的属性设置值和对其他bean的引用<br>③ 调用bean的初始化方法<br>④ bean可以使用了<br>⑤ 当容器关闭时，调用bean的销毁方法<br>在配置bean时，通过init-method和destroy-method 属性为bean指定初始化和销毁方法<br>6.bean的后置处理器<br>① bean后置处理器允许在调用初始化方法前后对bean进行额外的处理<br>② bean后置处理器对IOC容器里的所有bean实例逐一处理，而非单一实例。其典型应用是：检查bean属性的正确性或根据特定的标准更改bean的属性。<br>③ bean后置处理器时需要实现接口：<br>org.springframework.beans.factory.config.BeanPostProcessor。在初始化方法被调用前后，Spring将把每个bean实例分别传递给上述接口的以下两个方法：<br>*postProcessBeforeInitialization(Object, String)<br>*postProcessAfterInitialization(Object, String)<br>5.数据是如何注入的？<br>利用反射<br>3.什么是AOP?<br>4.AOP的实现原理?<br>5.AOP应用场景?</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组和链表对于内存以及CPU的访问缓存机制</title>
      <link href="/2020/06/04/arr-cpu/"/>
      <url>/2020/06/04/arr-cpu/</url>
      
        <content type="html"><![CDATA[<h3 id="CPU缓存对数组友好而对链表不友好"><a href="#CPU缓存对数组友好而对链表不友好" class="headerlink" title="CPU缓存对数组友好而对链表不友好"></a>CPU缓存对数组友好而对链表不友好</h3><p>数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，每一次CPU在读取内存中的数组时不是单纯的只读取某个特定的访问地址，而是读取一个<font color="red">数据块</font>（视情况而定的一段连续的内存地址），并保存到CPU的缓存中，下次访问时就会先从CPU缓存中查找，为的就是弥补CPU速度过快而内存过慢导致的速度差异。</p><p>对于数组和链表两种数据结构，由于数组是一块连续的内存空间，<font color="red">在读取某个下标的数据时CPU就会缓存连续的几个元素加载到缓存中，</font>而链表不是连续的，链表的节点是分散在堆空间（内存）里面,CPU缓存帮不上忙，这样数组执行速度会快于存储空间不连续的链表存储，理论上CPU访问数组比链表快了大约33倍</p><p>因此，程序中尽量使用连续的数据结构，这样可以充分发挥CPU缓存的威力。 这种对缓存友好的算法称为 <font color="red">Cache-oblivious algorithm</font></p>]]></content>
      
      
      <categories>
          
          <category> 缓存机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 链表 </tag>
            
            <tag> CPU缓存 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
